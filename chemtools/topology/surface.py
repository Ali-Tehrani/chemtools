
r"""
Data structure that holds the outer-atomic (OAS) and intra-atomic (IAS) surfaces.

Can be used for
- analyzing the IAS and OAS.
- integration over basins.
"""

import numpy as np

from grid.angular import AngularGrid
from grid.atomgrid import AtomGrid

__all__ = ["SurfaceQTAIM"]


class SurfaceQTAIM():
    def __init__(self, r_func, angular_degs, maximas, oas, ias, basins_ias,
                 refined_ang=None):
        self._r_func = r_func
        self._maximas = maximas
        self._angular_degs = angular_degs
        self._oas = oas
        self._ias = ias
        self._basins_ias = basins_ias
        self._refined_ang = refined_ang

    @property
    def r_func(self):
        # List[M, np.ndarray(N_i,)] ::math:`r_j(\theta_i, \phi_i)` for each M basins and N_i
        # angular points.
        return self._r_func

    @property
    def oas(self):
        # List[List[int]] : First list is over basins, second over indices of points of outeratomic
        # surface.
        return self._oas

    @property
    def ias(self):
        # List[List[int]] : First list is over basins, second over indices of points of interatomic
        # surface.
        return self._ias

    @property
    def maximas(self):
        # ndarray(M, 3) : The maxima of each basin.
        return self._maximas

    @property
    def angular_degs(self):
        # int or List[int] : List of angular degrees over each basin.
        return self._angular_degs

    @property
    def rad_grids(self):
        # List[OneDGrids] : List of M OneDGrids for integrating over radial component in [0, \inty).
        return self._rad_grids

    @property
    def basins_ias(self):
        return self._basins_ias

    @property
    def refined_ang(self):
        # List[M, np.ndarray(N_i, 2)] : Additional Angular points to append to the angular grid
        return self._refined_ang

    def save(self):
        save_dict = {
            "ias" : self.ias,
            "oas" : self.oas,
            "angular_degs" : self.angular_degs,
            "r_func": self.r_func
        }
        np.savez("qtaim_surface.npz", **save_dict, allow_pickle=True)

    def generate_angular_grid_of_basin(self, i_basin):
        # Note this doesn't include the extra angular points generated by refinement.
        deg = self.angular_degs
        deg = deg[i_basin] if isinstance(deg, list) else deg
        return AngularGrid(degree=deg)

    def generate_angular_pts_of_basin(self, i_basin):
        angular_grid = self.generate_angular_grid_of_basin(i_basin)
        points = angular_grid.points
        if self.refined_ang is not None:
            points = np.vstack((points, self.refined_ang[i_basin]))
        return points

    def get_atom_grid_over_basin(self, i_basin, rgrid=None):
        # integrate over a basin.
        deg = self.angular_degs
        deg = deg[i_basin] if isinstance(deg, list) else deg
        rgrid = self.rad_grids if rgrid is None else rgrid
        # If rgrid is a list for every center, then obtain the right one. Else is it is OneDGrid.
        if isinstance(rgrid, list):
            if len(rgrid) > 1:
                rgrid = self.rad_grids[i_basin]
            else:
                rgrid = rgrid[0]
        atom_grid = AtomGrid(rgrid, degrees=[deg], center=self.maximas[i_basin])

        for i_ias in self.ias[i_basin]:
            r_limit = self.r_func[i_basin][i_ias]

            for i_rad in range(atom_grid.rgrid.size):
                if atom_grid.rgrid.points[i_rad] > r_limit:
                    # Find where (r_{ij}, theta_i, phi_i) is and set the weights to zero.
                    i_start, i_final = atom_grid.indices[i_rad], atom_grid.indices[i_rad + 1]
                    atom_grid.weights[i_start + i_ias] = 0.0
        return atom_grid

    def generate_pts_on_surface(self, i_basin):
        sph_pts = self.generate_angular_pts_of_basin(i_basin)
        return self.maximas[i_basin] + self.r_func[i_basin][:, None] * sph_pts

    def get_ias_pts_of_basin(self, i_basin):
        ias = self.ias[i_basin]
        sph_pts = self.generate_angular_pts_of_basin(i_basin)
        return self.maximas[i_basin] + self.r_func[i_basin][ias, None] * sph_pts[ias]

    def get_oas_pts_of_basin(self, i_basin):
        oas = self.oas[i_basin]
        sph_pts = self.generate_angular_pts_of_basin(i_basin)
        return self.maximas[i_basin] + self.r_func[i_basin][oas, None] * sph_pts[oas]

    def interpolate_radial_func(self, method="smooth", ias=False, oas=False):
        # if method not in ["smooth", ]
        if ias and oas:
           raise ValueError(f"Both {ias} and {oas} cannot be true.")
        if ias:
            #TODO
            pass
        raise NotImplementedError(f"Not implemented yet.")
